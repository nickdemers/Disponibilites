require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe DisponibilitesController do

  # This should return the minimal set of attributes required to create a valid
  # Disponibilite. As you add validations to Disponibilite, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) { { "endroit_id" => "11", "niveau_id" => "12", "date_heure_debut" => DateTime.now + 1.minute, "date_heure_fin" => DateTime.now + 1.hour, "statut" => "waiting", "user_absent_id" => "11", "user_remplacant_id" => "12"} }

  describe "GET index" do
    describe "valid session" do
      before(:each) do
        @user = FactoryGirl.create(:user_admin)
      end
      it "admin user" do
        role = FactoryGirl.create(:role_admin)
        @user.roles= [role]

        sign_in @user

        #disponibilite = FactoryGirl.create(:disponibilite_disponible)

        #allow(Disponibilite).to receive(:where).with({:user_absent_id=>1})
        #allow(Disponibilite).to receive(:where).with({})
        #allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin",{date_debut: Date.current, :date_fin=> Date.current + 2.months}){nil}
        #allow(Disponibilite).to receive(:all) {[disponibilite]}

        get :index, {}
        is_expected.to render_template(:index)
        #assigns(:disponibilites).should eq([disponibilite])
      end
      it "permanent user" do
        role = FactoryGirl.create(:role_permanent)
        @user.roles= [role]

        sign_in @user

        get :index, {}
        is_expected.to render_template(:index)
      end
      it "remplacant user" do
        role = FactoryGirl.create(:role_remplacant)
        @user.roles= [role]

        sign_in @user

        get :index, {}
        is_expected.to render_template(:index)
      end
    end

    it "invalid session" do
      allow(request.env['warden']).to receive(:authorize!).and_throw(:warden, {:scope => :user})
      get :index, {}
      is_expected.to redirect_to(new_user_session_path)
    end
  end

  describe "GET show" do
    describe "valid session" do
      describe "assigns the requested disponibilite as @disponibilite" do
        before(:each) do
          user = FactoryGirl.create(:user_admin)
          role = FactoryGirl.create(:role)
          user.roles= [role]

          sign_in user

          allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin",{date_debut: Date.current, :date_fin=> Date.current + 2.months}) {nil}
        end

        it "with user_remplacant" do
          disponibilite = create(:disponibilite_attribue)

          allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

          user_absent = create(:user_permanent2)
          allow(User).to receive(:find).with(disponibilite.user_absent) { user_absent }

          user_remplacant = create(:user_remplacant2)
          allow(User).to receive(:find).with(disponibilite.user_remplacant) { user_remplacant }

          get :show, {:id => disponibilite}
          expect(assigns(:disponibilite)).to eq(disponibilite)
        end
        it "without user_remplacant" do
          disponibilite = create(:disponibilite_disponible)

          allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

          user_absent = create(:user_permanent2)
          allow(User).to receive(:find).with(disponibilite.user_absent) { user_absent }

          get :show, {:id => disponibilite}
          expect(assigns(:disponibilite)).to eq(disponibilite)
        end
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})
      disponibilite = create(:disponibilite_disponible)

      get :show, {:id => disponibilite}

      is_expected.to redirect_to(new_user_session_path)
    end
  end

  describe "GET new" do
    describe "valid session" do
      describe "user with permitted roles" do
        before(:each) do
          @user = FactoryGirl.create(:user_admin)
          role = FactoryGirl.create(:role)
          @user.roles= [role]

          sign_in @user

          allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin",{date_debut: Date.current, :date_fin=> Date.current + 2.months}) { nil }
        end

        it "assigns a new disponibilite as @disponibilite" do
          user_absent = create(:user_permanent2)
          allow(User).to receive(:where).with({"id" => @user.id}) { [@user] }
          allow(User).to receive(:where).with(:titre => "permanent") { user_absent }

          get :new, {}
          expect(assigns(:disponibilite)).to be_a_new(Disponibilite)
        end

        it "redirect to index, no user_absent available" do
          allow(User).to receive(:where).with({"id" => @user.id}) { [@user] }
          allow(User).to receive(:where).with(:titre => "permanent") { nil }

          get :new, {}
          is_expected.to redirect_to(disponibilites_url)
        end
      end
      it "user without roles" do
        user = FactoryGirl.create(:user_admin)
        role = FactoryGirl.create(:role_remplacant)
        user.roles= [role]

        sign_in user

        get :new, {}

        is_expected.to redirect_to(root_url)
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})

      get :new, {}

      is_expected.to redirect_to(new_user_session_path)
    end
  end

  describe "GET edit" do
    describe "valid session" do
      describe "user with permitted roles" do
        before(:each) do
          user = FactoryGirl.create(:user_admin)
          role = FactoryGirl.create(:role)
          user.roles= [role]

          sign_in user

          allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin",{date_debut: Date.current, :date_fin=> Date.current + 2.months}) { nil }
        end

        it "assigns the requested disponibilite as @disponibilite with user_remplacant" do
          disponibilite = FactoryGirl.create(:disponibilite_attribue)

          allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

          user_remplacant = FactoryGirl.build(:user_remplacant)
          user_permanent = build(:user_permanent)

          allow(User).to receive(:find).with("titre = 'permanent'") { user_permanent }

          allow(User).to receive(:find).with(disponibilite.user_remplacant) { user_remplacant }

          get :edit, {:id => disponibilite.to_param}
          expect(assigns(:disponibilite)).to eq(disponibilite)
          expect(disponibilite.user_remplacant).to eq(user_remplacant)
        end

        it "assigns the requested disponibilite as @disponibilite without user_remplacant" do
          disponibilite = create(:disponibilite_disponible)

          allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

          user_permanent = build(:user_permanent)

          allow(User).to receive(:find).with("titre = 'permanent'") { user_permanent }

          get :edit, {:id => disponibilite.to_param}
          expect(assigns(:disponibilite)).to eq(disponibilite)
          expect(disponibilite.user_remplacant).to be_nil
        end
      end
      it "user without permitted roles" do
        disponibilite = create(:disponibilite_attribue)

        user = FactoryGirl.create(:user_remplacant2)
        role = FactoryGirl.create(:role_remplacant)
        user.roles= [role]

        sign_in user

        get :edit, {:id => disponibilite.to_param}

        is_expected.to redirect_to(root_url)
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})
      disponibilite = create(:disponibilite_disponible)

      get :edit, {:id => disponibilite.to_param}

      is_expected.to redirect_to(new_user_session_path)
    end
  end

  describe "POST create" do
    describe "valid session" do
      before(:each) do
        @user = FactoryGirl.create(:user_admin)
        role = FactoryGirl.create(:role)
        @user.roles= [role]

        sign_in @user
      end
      describe "with valid params" do
        describe "with user_remplacant" do


          #it "creates a new Disponibilite" do
          #  disponibilite = build(:disponibilite_attribue)

          #  Disponibilite.stub(:new).and_return(disponibilite)

          #  expect {
          #    post :create, {disponibilite: {"endroit_id" => "11", "niveau_id" => "12", "date_heure_debut" => DateTime.now + 1.minute, "date_heure_fin" => DateTime.now + 1.hour, "statut" => disponibilite.statut, "user_absent_id" => @user_absent.id, "user_remplacant_id" => @user_remplacant.id}}, valid_session
          #  }.to change(Disponibilite, :count).by(1)
          #end

          it "assigns a newly created disponibilite as @disponibilite" do
            user_absent = create(:user_permanent2)
            allow(User).to receive(:where).with({"id" => @user.id}) { [@user] }
            allow(User).to receive(:where).with(:titre => "permanent") { user_absent }

            @user_remplacant = build_stubbed(:user_remplacant)
            User.stub_chain(:order, :joins, :where, :first).and_return(@user_remplacant)

            disponibilite = build(:disponibilite_attribue)

            allow(Disponibilite).to receive(:new) { disponibilite }

            allow(disponibilite).to receive(:save) { true }

            DisponibiliteMailer.stub_chain(:nouvelle_disponibilite_email, :deliver_later)

            post :create, {:disponibilite => valid_attributes}
            expect(assigns(:disponibilite)).to be_a(Disponibilite)
            #assigns(:disponibilite).should be_persisted

            expect(disponibilite.user_remplacant).to eq(@user_remplacant)
            expect(disponibilite.statut).to eq("waiting")
          end

          #it "redirects to the created disponibilite" do
          #  disponibilite = build(:disponibilite_attribue)

          #  Disponibilite.stub(:new).and_return(disponibilite)

          #  disponibilite.stub(:save).and_return(true)

          #  post :create, {disponibilite: {"endroit_id" => "11", "niveau_id" => "12", "date_heure_debut" => DateTime.now + 1.minute, "date_heure_fin" => DateTime.now + 1.hour, "statut" => "waiting", "user_absent_id" => "11", "user_remplacant_id" => @user_remplacant.id}}, valid_session
          #  response.should redirect_to(Disponibilite.last)
          #end
        end

        describe "without user_remplacant" do

          #it "creates a new Disponibilite" do
          #  expect {
          #    post :create, {disponibilite: {"endroit_id" => "11", "niveau_id" => "12", "date_heure_debut" => DateTime.now + 1.minute, "date_heure_fin" => DateTime.now + 1.hour, "statut" => "available", "user_absent_id" => @user_absent.id, "user_remplacant_id" => nil}}, valid_session
          #  }.to change(Disponibilite, :count).by(1)
          #end

          it "assigns a newly created disponibilite as @disponibilite" do
            user_absent = create(:user_permanent2)
            allow(User).to receive(:where).with({"id" => @user.id}) { [@user] }
            allow(User).to receive(:where).with(:titre => "permanent") { user_absent }

            User.stub_chain(:order, :joins, :where, :first).and_return(nil)

            disponibilite = build(:disponibilite_disponible)

            allow(Disponibilite).to receive(:new) { disponibilite }

            allow(disponibilite).to receive(:save) { true }

            post :create, {:disponibilite => valid_attributes}
            expect(assigns(:disponibilite)).to be_a(Disponibilite)
            #assigns(:disponibilite).should be_persisted

            expect(disponibilite.user_remplacant).to be_nil
            expect(disponibilite.user_remplacant).to be_nil
            expect(disponibilite.statut).to eq("available")
          end

          #it "redirects to the created disponibilite" do
          #  post :create, {disponibilite: {"endroit_id" => "11", "niveau_id" => "12", "date_heure_debut" => DateTime.now + 1.minute, "date_heure_fin" => DateTime.now + 1.hour, "statut" => "available", "user_absent_id" => @user_absent.id, "user_remplacant_id" => nil}}, valid_session
          #  response.should redirect_to(Disponibilite.last)
          #end
        end
      end

      describe "with invalid params" do
        before(:each) do
          allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin",{date_debut: Date.current, :date_fin=> Date.current + 2.months}) { nil }

          user_absent = create(:user_permanent2)
          allow(User).to receive(:where).with({"id" => @user.id}) { [@user] }
          allow(User).to receive(:where).with(:titre => "permanent") { user_absent }

          @user_remplacant = build_stubbed(:user_remplacant)
          User.stub_chain(:order, :joins, :where, :first).and_return(@user_remplacant)

          allow(Disponibilite).to receive(:save) { false }
        end

        it "assigns a newly created but unsaved disponibilite as @disponibilite" do
          # Trigger the behavior that occurs when invalid params are submitted
          post :create, {:disponibilite => { "user_absent_id" => "invalid value" }}
          expect(assigns(:disponibilite)).to be_a_new(Disponibilite)
        end

        it "re-renders the 'new' template" do
          # Trigger the behavior that occurs when invalid params are submitted
          post :create, {:disponibilite => { "user_absent_id" => "invalid value" }}
          expect(response).to render_template("new")
          expect(assigns(:disponibilite)).to be_a_new(Disponibilite)
        end
      end
    end

    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})

      post :create, {:disponibilite => valid_attributes}

      expect(response).to redirect_to(new_user_session_path)
    end
  end

  describe "PUT update" do
    describe "valid session" do
      before(:each) do
        @user = FactoryGirl.create(:user_admin)
        role = FactoryGirl.create(:role)
        @user.roles= [role]

        sign_in @user
      end

      describe "with valid params" do
        before (:each) do
          @disponibilite = create(:disponibilite_disponible)

          allow(Disponibilite).to receive(:find).with(@disponibilite.id.to_s) { @disponibilite }
          allow(@disponibilite).to receive(:update) { true }
        end

        it "updates the requested disponibilite" do
          put :update, {:id => @disponibilite.to_param, :disponibilite => { "user_absent_id" => "1" }}
        end

        it "assigns the requested disponibilite as @disponibilite" do
          put :update, {:id => @disponibilite.to_param, :disponibilite => valid_attributes}
          expect(assigns(:disponibilite)).to eq(@disponibilite)
        end

        it "redirects to the disponibilite" do
          put :update, {:id => @disponibilite.to_param, :disponibilite => valid_attributes}
          expect(response).to redirect_to(@disponibilite)
        end
      end

      describe "with invalid params" do
        before(:each) do
          allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin",{date_debut: Date.current, :date_fin=> Date.current + 2.months}) { nil }

          @disponibilite = create(:disponibilite_disponible)

          allow(Disponibilite).to receive(:find).with(@disponibilite.id.to_s) { @disponibilite }

          Disponibilite.any_instance.stub(:save).and_return(false)

          user_absent = create(:user_permanent2)
          allow(User).to receive(:where).with({"id" => @user.id}) { [@user] }
          allow(User).to receive(:where).with(:titre => "permanent") { user_absent }
        end

        it "assigns the disponibilite as @disponibilite" do
          # Trigger the behavior that occurs when invalid params are submitted
          put :update, {:id => @disponibilite.to_param, :disponibilite => { "user_absent_id" => "invalid value" }}
          expect(assigns(:disponibilite)).to eq(@disponibilite)
        end
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})
      @disponibilite = create(:disponibilite_disponible)

      put :update, {:id => @disponibilite.to_param, :disponibilite => { "user_absent_id" => "1" }}

      expect(response).to redirect_to(new_user_session_path)
    end
  end

  describe "DELETE destroy" do
    describe "valid session" do
      before(:each) do
        user = FactoryGirl.create(:user_admin)
        role = FactoryGirl.create(:role)
        user.roles= [role]

        sign_in user
      end

      it "redirects to the disponibilites list" do
        disponibilite = create(:disponibilite_disponible)

        allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }
        allow(disponibilite).to receive(:destroy)

        delete :destroy, {:id => disponibilite.to_param}
        expect(response).to redirect_to(disponibilites_url)
      end
    end

    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})
      disponibilite = create(:disponibilite_disponible)

      delete :destroy, {:id => disponibilite.to_param}

      expect(response).to redirect_to(new_user_session_path)
    end
  end

  describe "GET for_calendar" do
    describe "valid session" do
      before(:each) do
        user = FactoryGirl.create(:user_admin)
        role = FactoryGirl.create(:role)
        user.roles= [role]

        sign_in user
      end

      it "assigns disponibilites as @events" do
        disponibilite = [create(:disponibilite_disponible)]

        allow(Disponibilite).to receive(:where) { disponibilite }

        get :for_calendar, {start: 1417323600, end: 1420952400}, format: 'json'
        expect(assigns(:events)).to eq([{:id=>disponibilite[0].id, :title=>disponibilite[0].date_heure_debut.strftime("%H:%M") + " - " + disponibilite[0].date_heure_fin.strftime("%H:%M"), :className=>"event-red", :start=>disponibilite[0].date_heure_debut.strftime("%Y/%m/%d"), :end=>disponibilite[0].date_heure_fin.strftime("%Y/%m/%d"), :url=>disponibilite_path(disponibilite[0]), :nom_user_absent=>"Nicolas"}])
      end

      it "assigns disponibilites without @events" do
        allow(Disponibilite).to receive(:where) { [] }

        get :for_calendar, {start: 1417323600, end: 1420952400}, format: 'json'
        expect(assigns(:events)).to eq([])
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})

      get :for_calendar, {start: 1417323600, end: 1420952400}, format: 'json'

      expect(response).to redirect_to(new_user_session_path)
    end
  end

  describe "GET accept_availability" do
    describe "valid session" do
      before(:each) do
        @user = FactoryGirl.create(:user_remplacant)
        role = FactoryGirl.create(:role_remplacant)
        @user.roles= [role]

        sign_in @user
      end

      it "assigns disponibilite attribué as @disponibilite" do
        disponibilite = create(:disponibilite_disponible_with_remplacant)

        allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

        allow(disponibilite).to receive(:save) { true }

        get :accept_availability, {:id => disponibilite}
        expect(assigns(:disponibilite)).to eq(disponibilite)
        expect(disponibilite.statut).to eq("assigned")
      end


      it "assigns disponibilites without @events" do
        disponibilite = create(:disponibilite_disponible_with_remplacant)

        allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

        allow(disponibilite).to receive(:save) { false }

        get :accept_availability, {:id => disponibilite}

        allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin and user_remplacant_id = :user_remplacant_id",{date_debut: Date.current, date_fin: Date.current + 2.months, user_remplacant_id: @user.id}){disponibilite}

        user_permanent = build(:user_permanent)

        allow(User).to receive(:find).with("titre = 'permanent'") { user_permanent }
        expect(response).to redirect_to(disponibilite)
        expect(disponibilite.statut).to eq("assigned")
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})

      disponibilite = create(:disponibilite_disponible_with_remplacant)

      get :accept_availability, {:id => disponibilite}

      expect(response).to redirect_to(new_user_session_path)
    end
  end

  describe "GET deny_availability" do
    describe "valid session" do
      before(:each) do
        @user = FactoryGirl.create(:user_remplacant)
        role = FactoryGirl.create(:role_remplacant)
        @user.roles= [role]

        sign_in @user
      end

      it "assigns disponibilite refusé as @disponibilite" do
        disponibilite = create(:disponibilite_disponible_with_remplacant)

        allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

        allow(disponibilite).to receive(:save) { true }

        get :deny_availability, {:id => disponibilite}
        expect(assigns(:disponibilite)).to eq(disponibilite)
        expect(disponibilite.statut).to eq("denied")
      end

      it "assigns disponibilites without @events" do
        disponibilite = create(:disponibilite_disponible_with_remplacant)

        allow(Disponibilite).to receive(:find).with(disponibilite.id.to_s) { disponibilite }

        allow(disponibilite).to receive(:save) { false }

        get :deny_availability, {:id => disponibilite}

        allow(Disponibilite).to receive(:where).with("(statut = 'waiting' or statut = 'available') and date_heure_debut between :date_debut and :date_fin and user_remplacant_id = :user_remplacant_id",{date_debut: Date.current, date_fin: Date.current + 2.months, user_remplacant_id: @user.id}){disponibilite}

        user_permanent = build(:user_permanent)

        allow(User).to receive(:find).with("titre = 'permanent'") { user_permanent }
        expect(response).to redirect_to(disponibilite)
        expect(disponibilite.statut).to eq("denied")
      end
    end
    it "invalid session" do
      allow(request.env['warden']).to receive(:authenticate!).and_throw(:warden, {:scope => :user})

      disponibilite = create(:disponibilite_disponible_with_remplacant)

      get :deny_availability, {:id => disponibilite}

      expect(response).to redirect_to(new_user_session_path)
    end
  end
end
